# 데이터베이스 저장 구조

## 테이블과 인덱스의 분리형

데이터를 저장하는 테이블과 특정한 데이터를 찾기 위한 경로로 사용되는 인덱스가 전혀 별개의 객체로써 존재하는 저장 형태가 있다. 사실 관계형 데이터베이스 이전에서는 대부분 키(Key)와 데이터가 매우 밀접한 관련이 있었다. 저장된 데이터에서 특정한 범위를 선별해서 찾고자 한다면 키의 도움을 받아야 했다. 이로 인해 데이터의 저장은 필연적으로 키의 영향을 받을 수 밖에 없었다.

따라서 키를 찾기만 하면 거기서 바로 우리가 원하는 데이터를 찾을 수 있어야 하기 때문에 키를 찾는 것이 곧 데이터를 찾는 것이 되었다. 이 때문에 키는 항상 데이터를 옆에 두어야만 했다. 그러나 만약 키와 데이터가 서로 떨어져 있더라도 키를 찾아갔을 때 데이터 위치를 언제라도 알 수만 있다면, 굳이 키 옆에 데이터를 달아 둘 필요는 없을 것이다. 물론 키에서 다시 데이터를 찾아가야 하는 부담은 추가되어야 한다.

그 대신 데이터를 저장할 때는 인덱스에 영향을 받지 않으므로 이런 면에서는 부담이 크게 감소한다. 테이블과 인덱스가 별도로 분리되어 있는 구조는 관계형 데이터베이스의 가장 일반적인 데이터 저장형식이다. 비록 장점에 못지 않게 많은 단점을 가지고 있지만 대용량의 데이터를 관리하기 위해서는 이 구조가 가장 타당하기 때문이다.

## 분리형 테이블의 구조

데이터를 저장하려면 먼저 **테이블스페이스(Tablespace)**를 생성해야 한다. 테이블스페이스란 논리적인 저장공간이다. 테이블스페이스는 여러 개의 물리적인 **데이터파일(Datafile)**로 구성된다. 테이블스페이스를 용도별로 나눌 수 있는데 이것을 **세그먼트(Segment)**라고 부른다. 세그먼트는 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트다. 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블스페이스에 저장할지를 지정한다.

![https://docs.oracle.com/cd/A84870_01/doc/server.816/a76965/c03spac4.gif](https://docs.oracle.com/cd/A84870_01/doc/server.816/a76965/c03spac4.gif)

[https://docs.oracle.com/cd/A84870_01/doc/server.816/a76965/c03spac4.gif](https://docs.oracle.com/cd/A84870_01/doc/server.816/a76965/c03spac4.gif)

세그먼트는 여러 **익스텐트(extent)**로 구성된다. 파티션 구조가 아니라면 테이블도 하나의 세그먼트요, 인덱스도 하나의 세그먼트다. 테이블 또는 인덱스가 파티션 구조라면, 각 파티션이 하나의 세그먼트가 된다. LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다.

> 파티션
파티셔닝(Partitioning)은 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠서 저장하는 것을 말한다.
예를 들어 계절별로 옷을 관리하면 외출할 때 필요한 옷을 쉽고 바르게 찾을 수 있다. 데이터도 월별, 분기별 반기별, 연별로 분할해서 저장해 두면 빠르게 조회할 수 있고, 관리하기도 쉽다. 일반적으로 시계열에 따라 Range 방식으로 분할하지만, 그 외 다른 기 준(리스트 또는 해시 방식)으로 분할할 수도 있다.
> 

![https://docs.oracle.com/database/121/CNCPT/img/GUID-7C93F247-ED66-465B-BC4A-357C0D8431C8-default.gif](https://docs.oracle.com/database/121/CNCPT/img/GUID-7C93F247-ED66-465B-BC4A-357C0D8431C8-default.gif)

[https://docs.oracle.com/database/121/CNCPT/img/GUID-7C93F247-ED66-465B-BC4A-357C0D8431C8-default.gif](https://docs.oracle.com/database/121/CNCPT/img/GUID-7C93F247-ED66-465B-BC4A-357C0D8431C8-default.gif)

익스텐트는 공간을 확장하는 단위다. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받는다, **익스텐트는 연속된 블록들의 집합**이기도 하다.

익스텐트 단위로 공간을 확장하지만, 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록이다. 참고로 DB2, SQL Server 같은 DBMS는 블록 대신 페이지(page)라는 용어를 사용한다. **한 블록은 하나의 테이블이 독접한다.** 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다. **한 익스텐트도 하나의 테이블이 독점한다.** 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다.

**세그먼트에 할당된 모든 익스텐트는 같은 데이터파일에 위치하지 않을 수 있다.** 아니, 서로 다른 데이터파일에 위치할 가능성이 더 높다. 하나의 테이블스페이스를 여러 데이터파일로 구성하면, 파일 경합을 줄이기 위해 DBMS가 데이터를 가능한 한 여러 데이터파일로 분산해서 저장하기 때문이다. 익스텐트 내 블록은 서로 인접한 연속된 공간이지만, 익스텐트끼리는 연속된 공간이 아니다.

위에 나온 개념들을 정리하면 다음과 같다.

- 블록 : 데이터를 읽고 쓰는 단위
- 익스텐트 : 공간을 확장하는 단위. 연속된 블록 집합
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
- 테이블 스페이스 : 세그먼트를 담는 콘테이너
- 데이터파일 : 디스크 상의 물리적인 OS 파일

### DBA(Database Block Address)

모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖는다. 이 주소값을 ‘DBA(Database Block Address)’라고 부른다. 데이터를 읽고 쓰는 단위가 블록이므로 데이터를 읽으려면 먼저 DBA부터 확인해야 한다.

인덱스를 이용해 테이블 레코드를 읽을 때는 인덱스 ROWID를 이용한다. ROWID는 DBA + 로우 번호(블록 내 순번)로 구성되므로 이를 분해하면 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있다.

테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다. 익스텐트 맵을 통해 각 익스텐트의 첫 번재 블록 DBA를 알 수 있다. 익스텐트는 연속된 블록 집합이므로 테이블을 스캔할 때는 첫 번째 블록 뒤에 연속해서 저장된 블록을 읽으면 된다.

## 참조

<조시형, 친절한 SQL 튜닝, DBian>

<이화식, 새로쓴, 대용량 데이터베이스 솔루션 vol.1, 엔코아컨설팅>
