# 작성중

# InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 하지만 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다. MySQL 5.0 이하 버전에서 InnoDB의 잠금 정보를 진단할 수 있는 도구라고는 lock_monitor(innodb_lock_monitor라는 이름의 InnoDB 테이블을 생성하는 방법)를 이용한 “SHOW ENGINE INNODB STATUS” 명령이 전부다. 하지만 이 내용도 거의 어셈블리 코드를 보는 것 같아서 이해하기가 상당히 어렵다.

하지만 MySQL 5.1부터 InnoDB 플러그인 스토리지 엔진이 되입되면서부터 InnoDB의 트랜잭션과 잠금 그리고 잠금 대기중인 트랜잭션의 목록을 조회할 수 잇는 방법이 도입됐다. MySQL 서버의 INFORMATION_SCHEMA라는 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며, 장시간 잠금을 가지고 있는 클라이언트를 종료시키는 것도 가능하다.

### InnoDB의 잠금 방식

아직도 인터넷을 통해 낙관점 잠금(Optimistic locking)이나 비관적 잠금(Pessimistic locking)이라는 표현을 자주 접했을 것이다. 낙관이나 비관이라는 말 자체는 어렵지 않지만 쉽게 이해되지 않는 개념 중 하나인 것 같아서 간단히 소개하고 넘어가겠다.

사실 쿼리 개발이나 튜닝에는 크게 영향은 없는듯하여, 기본 지식 적도로 익혀두면 좋을 듯하다)

**비관적 잠금(Pessimistic locking)**

현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라고 한다. 이 처리 방식에서 느낄 수 있듯이 “현재 변경하고자 하는 레코드를 다른 트랜잭션에서도 변경할 수 있다”라는 비관적인 가정을 하기 때문에 먼저 잠금을 획득한 것이다. 그래서 비관적 잠금이라고 부른다. 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있으며 **InnoDB는 비관적 잠금 방식을 채택하고 있다**.

**낙관적 잠금(Optimistic locking)**

낙관적 잠금에서는 기본적으로 각 트랜잭션이 같은 레코드르 변경할 가능성은 상당히 희박할 것이라고(낙관적으로) 가정한다. 그래서 우선 변경 작업을 수행하고 마지막에 잠금 충돌이 있었는지 확인해 문제가 있었다면 ROLLBACK 처리하는 방식을 의미한다.

### InnoDB의 잠금 종류

InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다. 일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재하는데, 간단히 그림으로 살펴보자.

**레코드 락(Record lock)**

**갭 락(Gap lock)**

**넥스트 키 락(Next key lock)**

### 인덱스와 잠금

InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있기 때문에 다시 한번 더 자세히 살펴보자. “레코드 락”을 소개하면서 잠깐 언급했듯이 InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.

```
> SELECT COUNT(*) FROM EMPLOYEES WHERE FIRST_NAME='georgi';
253
> SELECT COUNT(*) FROM EMPLOYEES WHERE FIRST_NAME='georgi' AND LAST_NAME='Klassen';
1
> UPDATE EMPLOYEES SET HIRE_DATE=NOW() 
  WHERE FIRST_NAME='georgi' AND LAST_NAME='Klassen';
```

`UPDATE` 문장이 실행되면 1건의 레코드가 업데이트될 것이다. 하지만 이 1건의 업데이트를 위해 몇개의 레코드에 락을 걸어야 할까? 이 `UPDATE` 문장의 조건에서 인덱스를 이용할 수 잇는 조건은 `FIRST_NAME='georgi'` 이며 `LAST_NAME` 칼럼은 인덱스에 없기 때문에  `FIRST_NAME='georgi'` 인 레코드 253건의 레코드가 모두 잠긴다. 아마 오라클과 같은 DBMS에 익숙한 사용자라면 상당히 이상하게 생각할 것이며, 이러한 부분을 잘 모르고 개발하게 되면 MySQL 서버를 제대로 이용하지 못하게 될 것이다. 또한 이런 MySQL의 특성을 알지 못하면 “MySQL은 정말 이상한 DBMS”다 라고 생각하게 될 것이다. 이 예제에서는 몇 건 안되는 레코드만 잠그지만 UPDATE 문장을 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 `UPDATE` 작업을 하고 있는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생할 것이다.

만약 이 테이블에 인덱스가 하나도 없다면 어떻게 될까? 이러한 경우에는 테이블을 풀 스캔하면서 `UPDATE` 작업을 하는데, 이 과정에서 테이블에 있는 30여 만 건의 모든 레코드를 잠그게 된다. 이것이 MySQL의 방식인 것이며, 또한 MySQL의 InnoDB에서 인덱스 설계가 중요한 이유 또한 이 때문이다.

### 트랜잭션 격리 수준과 잠금

‘인덱스와 잠금’에서 살펴본 InnoDB의 불필요한 레코드이 잠금 현상은 InnoDB의 넥스트 키 락 때문에 발생하는 것이다. 하지만 InnoDB에서 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그때문이다. 아직 많이 사용되지는 않지만 레코드 기반의 바이너리 로그(Row based binary log)를 사용하거나 바이너리 로그를 사용하지 않는 경우에는 InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다. InnoDB의 갭 락이나 넥스트 키 락을 줄일 수 있다는 것은 사용자의 쿼리 요청을 동시에 더 많이 처리할 수 있음을 의미한다.

다음 조합으로 MySQL 서버가 가동하는 경우에느 InnoDB에서 사용되는 대부분의 갭 락이나 넥스트 키 락을 제거할 수 있다.
