# InnoDB 스토리지 엔진의 잠금

**InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다**. InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 하지만 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다. MySQL 5.0 이하 버전에서 InnoDB의 잠금 정보를 진단할 수 있는 도구라고는 lock_monitor(innodb_lock_monitor라는 이름의 InnoDB 테이블을 생성하는 방법)를 이용한 “SHOW ENGINE INNODB STATUS” 명령이 전부다. 하지만 이 내용도 거의 어셈블리 코드를 보는 것 같아서 이해하기가 상당히 어렵다.

하지만 MySQL 5.1부터 InnoDB 플러그인 스토리지 엔진이 되입되면서부터 InnoDB의 트랜잭션과 잠금 그리고 잠금 대기중인 트랜잭션의 목록을 조회할 수 잇는 방법이 도입됐다. MySQL 서버의 INFORMATION_SCHEMA라는 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며, 장시간 잠금을 가지고 있는 클라이언트를 종료시키는 것도 가능하다.

### InnoDB의 잠금 방식

낙관점 잠금(Optimistic locking)이나 비관적 잠금(Pessimistic locking)이라는 표현을 자주 접했을 것이다. 사실 쿼리 개발이나 튜닝에는 크게 영향은 없는듯하지만, 기본 지식 정도로 정리해 보자.

**비관적 잠금(Pessimistic locking)**

현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라고 한다. 이 처리 방식에서 느낄 수 있듯이 “현재 변경하고자 하는 레코드를 다른 트랜잭션에서도 변경할 수 있다”라는 비관적인 가정을 하기 때문에 먼저 잠금을 획득한 것이다. 그래서 비관적 잠금이라고 부른다. 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있으며 **InnoDB는 비관적 잠금 방식을 채택하고 있다**.

**낙관적 잠금(Optimistic locking)**

낙관적 잠금에서는 기본적으로 각 트랜잭션이 같은 레코드르 변경할 가능성은 상당히 희박할 것이라고(낙관적으로) 가정한다. 그래서 우선 변경 작업을 수행하고 마지막에 잠금 충돌이 있었는지 확인해 문제가 있었다면 ROLLBACK 처리하는 방식을 의미한다.

### InnoDB의 잠금 종류

InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다. 일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재한다.

**레코드 락(Record lock)**

레코드 자체만을 잠그는 것을 레코드 락이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다. 한 가지 중요한 차이는 **InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다**는 점이다. InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 이어서 설명할 넥스트 키 락(Next Key lock) 또는 갭 락(Gap lock)을 사용하지만, 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업은 갭(Gap, 간격)에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

**갭 락(Gap lock)**

다른 DBMS와의 또 다른 차이가 바로 갭(GAP) 락이라는 것이다. **갭 락은 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미**한다. 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것이다. 갭 락이라는 것은 개념일 뿐이지 자체적으로 사용되지는 않고, 이어서 설명할 넥스트 키 락의 일부로 사용된다.

**넥스트 키 락(Next key lock)**

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다. STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 `REAPEATABLE READ` 격리 수준을 사용해야 한다. 또한 `innodb_locks_unsafe_for_binlog` 파라미터가 비활성화되면(파라미터 값이 0으로 설정되면) 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다. **InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적**이다. 그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다. 하지만 아직 ROW 포맷의 바이너리 로그는 그다지 널리 사용되지 않기 때문에 안정성을 확인하는 것이 어려운 상태이며, 또한 STATEMENT 포맷의 바이너리 로그에 비해 로그 파일의 크기가 상당히 커질 가능성이 많다.

### 인덱스와 잠금

InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있기 때문에 다시 한번 더 자세히 살펴보자. “레코드 락”을 소개하면서 잠깐 언급했듯이 **InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리**된다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.

```
> SELECT COUNT(*) FROM EMPLOYEES WHERE FIRST_NAME='georgi';
253
> SELECT COUNT(*) FROM EMPLOYEES WHERE FIRST_NAME='georgi' AND LAST_NAME='Klassen';
1
> UPDATE EMPLOYEES SET HIRE_DATE=NOW() 
  WHERE FIRST_NAME='georgi' AND LAST_NAME='Klassen';
```

`UPDATE` 문장이 실행되면 1건의 레코드가 업데이트될 것이다. 하지만 이 1건의 업데이트를 위해 몇개의 레코드에 락을 걸어야 할까? 이 `UPDATE` 문장의 조건에서 인덱스를 이용할 수 잇는 조건은 `FIRST_NAME='georgi'` 이며 `LAST_NAME` 칼럼은 인덱스에 없기 때문에  `FIRST_NAME='georgi'` 인 레코드 253건의 레코드가 모두 잠긴다. 아마 오라클과 같은 DBMS에 익숙한 사용자라면 상당히 이상하게 생각할 것이며, 이러한 부분을 잘 모르고 개발하게 되면 MySQL 서버를 제대로 이용하지 못하게 될 것이다. 또한 이런 MySQL의 특성을 알지 못하면 “MySQL은 정말 이상한 DBMS”다 라고 생각하게 될 것이다. 이 예제에서는 몇 건 안되는 레코드만 잠그지만 UPDATE 문장을 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 `UPDATE` 작업을 하고 있는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생할 것이다.

만약 이 테이블에 인덱스가 하나도 없다면 어떻게 될까? 이러한 경우에는 테이블을 풀 스캔하면서 `UPDATE` 작업을 하는데, 이 과정에서 테이블에 있는 30여 만 건의 모든 레코드를 잠그게 된다. 이것이 MySQL의 방식인 것이며, 또한 MySQL의 InnoDB에서 인덱스 설계가 중요한 이유 또한 이 때문이다.

### 트랜잭션 격리 수준과 잠금

‘인덱스와 잠금’에서 살펴본 InnoDB의 불필요한 레코드이 잠금 현상은 InnoDB의 넥스트 키 락 때문에 발생하는 것이다. 하지만 **InnoDB에서 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그때문**이다. 아직 많이 사용되지는 않지만 레코드 기반의 바이너리 로그(Row based binary log)를 사용하거나 바이너리 로그를 사용하지 않는 경우에는 InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다. InnoDB의 갭 락이나 넥스트 키 락을 줄일 수 있다는 것은 사용자의 쿼리 요청을 동시에 더 많이 처리할 수 있음을 의미한다.

다음 조합으로 MySQL 서버가 가동하는 경우에는 InnoDB에서 사용되는 대부분의 갭 락이나 넥스트 키 락을 제거할 수 있다.

> 트랜잭션의 격리 수준은 [링크](https://github.com/eastshine-high/til/blob/main/relational-database/transaction-lock/transaction.md) 를 통해 정리하였습니다.

| 버전 | 설정의 조합 |
| --- | --- |
| MySQL 5.0 | innodb_locks_unsafe_for_binlog=1, 2. 트랜잭션 격리 수준을 READ-COMMITTED로 설정 |
| MySQL 5.1 이상 | 1. 바이너리 로그를 비활성화, 2. 트랜잭션 격리 수준을 READ-COMMITTED로 설정 |
| MySQL 5.1 이상 | 1. 레코드 기반의 바이너리 로그 사용, 2. innodb_locks_unsafe_for_binlog=1, 3. 트랜잭션 격리 수준을 READ-COMMITTED로 설정 |

MySQL 5.0 버전에서는 바이너리 로그가 비활성화되지 않아도 트랜잭션의 격리 수준을 READ-COMMITTED로 설정하는 것이 가능했다. 그래서 바이너리 로그의 사용 여부와 관계 없이 innodb_locks_unsafe_for_binlog 시스템 설정 값을 1로 설정하고 트랜잭션의 격리 수준을 READ-COMMITTED로 설정해 대부분의 갭 락이나 넥스트 키 락을 제거할 수 있었다. 하지만 MySQL 5.1 이상의 버전에서는 바이너리 로그(문장 기반의 바이너리 로그의 경우만)가 활성화되면 최소 REPEATABLE-READ 이상의 격리 수준을 사용하도록 강제되고 있기 때문에 조금 내용이 달라진 것이다. 여기서 “대부분”의 갭 락이나 넥스트 키 락이 없어진다고 한 것은 이 조합의 설정에서도 유니크키나 외래키에 대한 갭 락은 없어지지 않기 때문이다.

또한 위 조합으로 설정되면 ‘인덱스와 잠금’에서 언급했던 불필요한 잠금도 일부 없어진다. UPDATE 문장을 처리하기 위해 일치하는 레코드를 인덱스를 이용해 검색할 때, 우선 인덱스만을 비교해서 일치하는 레코드에 대해 배터적 잠금을 걸게 되지만, 그다음 나머지 조건을 비교해서 일치하지 않는 레코드는 즉시 잠금을 해제한다.

---

**참조**

<이성욱, Real MySQL, 위키북스>
