# Process

초기의 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행하도록 허용하였다. 이 프로그램이 시스템에 대한 완전한 제어를 가지고, 시스템의 모든 자원에 접근할 수 있었다. 반면 **오늘날의 컴퓨터 시스템들은 메모리에 다수의 프로그램들이 적재되어 병행 실행되는 것을 허용**한다. 이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고 보다 구획화할 것을 필요로 했다. **이러한 필요성이 프로세스의 개념을 낳았으며, 프로세스란 실행 중인 프로그램을 말한다.** 프로세스는 **현대의 시분할 시스템에서 작업의 단위**이다.

- **실행 중인 프로그램을 의미**한다.
- 운영체제에서 할당하는 작업의 단위이다.
- 프로세스는 때로는 **텍스트 섹션**으로 알려진 프로그램 코드 이상의 무엇이다.
- 프로세스는 또한 **프로그램 카운터**의 값과 처리기 레지스터의 내용으로 대표되는 현재 활동을 포함한다.
- 프로세스는 일반적으로 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시적인 자료를 가지는 **프로세스 스택**과 전역 변수들을 수록하는 **데이터 섹션**을 포함한다.
- 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 **힙**을 포함한다.
- 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.

<br>

## 프로세스의 상태(Process state)

### 프로세스의 5가지 상태

- 생성(New) : 처음 프로세스 생성 상태
- 준비(Ready) : CPU 할당을 기다리는 상태
- 실행(Run) : 프로세스가 처리되는 상태
- 대기(Wait) : 특정 자원의 할당이나 입출력 작업의 종료 때까지 보류되는 상태
- 종료(Terminated) : 모든 처리가 완료된 상태

![http://itwiki.kr/images/d/da/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png](http://itwiki.kr/images/d/da/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png)

[http://itwiki.kr/images/d/da/프로세스_상태전이도.png](http://itwiki.kr/images/d/da/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png)

- 생성 → 준비 : 프로세스 생성이 완료된 경우
- 준비 → 실행 : 스케줄러에 의해 선택된 경우. **디스패치(dispatch)**라고 함
- 실행 → 준비 : 할당시간 만료 또는 보다 높은 우선순위의 프로세스가 오는 경우
- 실행 → 대기 : 페이지 교환, 입출력 잡업 등이 필요한 경우
- 대기 → 준비 : 페이지 교환, 입출력 잡업 등이 완료된 경우
- 실행 → 종료 : 프로세스를 성공적으로 끝마친 경우

<br>

## 프로세스 제어 블록 (Process Control Block)

**각 프로세스는 운영체제에서 프로세스 제어 블록**(Process Control Block)(태스크 제어 블록 이라고도 불린다)**에 의해 표현된다.** 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며,  프로세스의 진행에 따라 정보의 변경도 발생한다. **문맥 교환을 위한 필수 요소이다.** 다음과 같은 것들을 포함한다.

- **프로세스 상태** : 상태는 새로운(new), 준비완료(ready), 실행(running), 대기(waiting), 또는 정지(halted) 상태 등이다.
- **프로그램 카운터** : 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
- **CPU 레지스터들** : 프로그램 카운터와 함께 이 상태 정보는, 나중에 프로세스가 계속 올바르게 실행되도록 하기 위해서, 인터럽트 발생 시 저장되어야 한다. 레지스터에는 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태 코드(condition code) 정보가 포함된다.
- **CPU-스케줄링 정보** : 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수들을 포함한다.(프로세스 스케줄링)
- **메모리 관리 정보** : 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 기준(base) 레시트어와 한계(limit) 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다.(메모리 관리 전략)
- **회계(accounting) 정보** : 이 정보는 CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호(PID) 등을 포함한다.
- **입출력 상태 정보** : 이 정보는 이 프로세스에게 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

<br>

## 프로세스에 대한 연산(Operation on Processes)

대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고, 제거되어야 한다. 그러므로 운영체제는 프로세스 **생성** 및 **종료**를 위한 기법을 제공해야 한다.

<br>

### 프로세스 생성(Process creation)

프로세스는 실행 과정 동안 프로세스 생성 시스템 호출을 이용하여 여러 개의 프로세스를 생성할 수 있다. 생성하는 프로세스를 부모 프로세스(parent process)라 하고, 생성된 새로운 프로세스는 자식 프로세스(child process)라고 한다. 이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며, 그 결과 프로세스의 트리를 형성한다.

UNIX, Linux 및 Windows와 같은 대부분의 현대 운영체제들은 유일한 프로세스 식별자(pid)를 사용하여 프로세스를 구분하는데 이 식별자는 보통 정수이다. pid는 시스템의 각 프로세스에게 고유한 값을 가지도록 할당된다. 이 식별자를 통하여 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 찾아보기(index)로 사용된다.

![https://media.cheggcdn.com/media/ef3/ef37b1a3-efbf-4f29-b4b2-432c40cfa3eb/php5ApJWd.png](https://media.cheggcdn.com/media/ef3/ef37b1a3-efbf-4f29-b4b2-432c40cfa3eb/php5ApJWd.png)

[https://media.cheggcdn.com/media/ef3/ef37b1a3-efbf-4f29-b4b2-432c40cfa3eb/php5ApJWd.png](https://media.cheggcdn.com/media/ef3/ef37b1a3-efbf-4f29-b4b2-432c40cfa3eb/php5ApJWd.png)

위 그림은 Linux 운영체제의 전형적인 프로세스 트리를 보여 주고 있으며 프로세스 이름과 pid를 보이고 있다. 언제나 pid가 1인 Init 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행한다. 시스템이 부팅되면 Init 프로세스는 다양한 사용자 프로세스를 생성한다. 이러한 프로세스에는 웹 또는 프린트 서버, ssh 서버 등이 포함된다.

프로세스의 생성과 관련된 작업으로는 프로세스의 이름을 결정하고 프로세스 준비 큐에 삽입하며 프로세스에 초기 우선순위를 부여하고 그 프로세스에 대한 프로세스 제어 블록을 만드는 등의 일이 따르게 된다.

일반적으로 프로세스는 작업을 수행하기 위하여 자원(CPU, 메모리, 파일, 입출력 장치)이 필요하다. 한 프로세스가 자식 프로세스를 생성하면 생성된 자식 프로세스는 운영체제로부터 직접 자원을 얻거나(CreateProcess(), Windows) 부모 프로세스 자원의 일부(혹은 상속)를 얻는다(fork(), Linux). 부모 프로세스는 자식 프로세스에게 자원을 나누어 주거나 공유할 수 있도록 한다. 자식 프로세스의 자원을 부모 프로세스의 자원으로 제한하는 이유는 너무 많은 서브 프로세스를 생성함으로써 시스템 과부하(overload)가 걸리는 것을 방지하기 위함이다.

<br>

### 프로세스 종료(Process termination)

프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 호출을 사용하여 운영체제에게 자신의 삭제를 요청하면 종료한다. 이 시점에서 프로세스는 자신의 부모 프로세스에(wait 시스템 호출을 통해) 상태 값(통상 정수값)을 반환할 수 있다. 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 운영체제로 반납된다.

프로세스 종료가 발생하는 다른 경우가 있다. 한 프로세스는 적당한 시스템 호출(예를 들어 Windows의 TerminateProdcess())을 통해서 다른 프로세스의 종료를 유발할 수 있다. 통상적으로, 그런 시스템 호출은 단지 종료될 프로세스의 부모만이 호출할 수 있다. 그렇지 않으면, 사용자가 서로의 다른 작업을 임의적으로 중단(kill)시킬 수 있을 것이다. 부모가 자식을 종료시키기 위해서는 자식의 pid를 알아야 한다는 것에 유의하자. 그러므로 한 프로세스가 새로운 프로세스를 만들 때, 새로 만들어진 프로세스의 신원(identity)이 부모에게 전달된다.

부모는 다음과 같이 여러 가지 이유로 인하여 자식들 중 하나의 실행을 종료할 수 있다.

- 자식이 자신에게 할당된 자원을 초과하여 사용할 때, 이때는 부모가 자식들의 상태를 검사할 수 있는 방편이 주어져야 한다.
- 자식에게 할당된 테스크(task)가 더 이상 필요 없을 때
- 부모가 exit를 하는데, 운영체제에서 부모가 exit한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우.

몇몇 시스템에서는 부모 프로세스가 종료한 이후에 자식 프로세스가 존재할 수 없다. 그러한 시스템에서는 프로세스가 종료되면(정상적이던 비정상적이던) 그로부터 비롯된 모든 자식 프로세스들도 종료되어야 한다. 이것을 연쇄식 종료(cascading termination)라고 부르며 이 작업은 운영체제가 시행한다.

<br>

### Reference

<운영체제 9th, Abraham Silberschatz 외, 교보문고>
