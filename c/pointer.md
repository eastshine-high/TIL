# 메모리와 포인터

### 컴퓨터와 메모리

연산자를 지나 제어문, 함수를 배우면서 사실 컴퓨터라는 기계 자체와 관련된 이론들은 의도적으로 배제된 경향이 있었습니다. 프로그래밍이라는 것이 꼭 하드웨어적 이해를 기반으로 해야만 하는 것은 아니기 때문입니다.

**하지만 C언어는 운영체제나 하드웨어를 제어하기 위한 도구로 매우 유용합니다.** 메모리를 직접 다룬다는 것은 어쩌면 머리 아픈 일인지도 모릅니다 .그러나 **코드와 기계의 결합이 한눈에 들어오는 순간을 경험하면, C언어 만큼 괜찮은 프로그래밍 언어도 없다고 생각하게 될 지 모릅니다.**

**변수의 본질은 메모리**이며 모든 메모리는 자신의 위치를 식별하기 위한 근거로 고유번호(일련번호)를 갖는데, 이 번호를 메모리의 주소라 합니다. 32비트 응용프로그램에서 1바이트 단위 메모리에 부여된 일련번호는 부호가 없는 32비트 정수이며($2^{32}$=4GB), 보통 16진수(0xFF000003)로 표기합니다.

그리고 **주소로 메모리를 식별하는 것은 low-level 특성**입니다. high-level에서는 주소보다는 이름(식별자)으로 식별합니다. 따라서 **변수의 선언 및 정의는 메모리 확보를 의미**하며, 선언 시 부여한 이름으로 확보한 메모리를 식별합니다.

<br>

### 주소 번지 연산자

어떤 연산자는 메모리에 저장된 정보가 아니라 변수의 이름 즉, **메모리 자체에 관심**이 있기도 합니다. 그중 가장 대표적인 것이 바로 단항 연산자인 **주소 번지 연산자**입니다.

```c
int main(void)
{
    int nData = 10;

    //변수 nData에 들어 있는 값을 출력
    printf("%d\n",nData);

    //변수 nData의 메모리 주소를 16진수로 출력
    printf("%p\n",&nData);

    return 0;
}

실행결과
10
0012FF28
```

이 구문의 실행결과로 0012FF28이라는 값이 출력되었는데, 이는 시스템마다 다를 수 있습니다. 출력된 결과를 **요약**하면 "이름이 nData인 부호가 있는 32비트 정수형 메모리의 실제 주소는 0x0012FF28이고, 그 안에 저장된 정보를 해석하면 10진 정수인 10이다."

<br>

### 포인터 변수의 선언 및 정의

**포인터 변수(`*`varName)는 메모리의 주소**(바이트 단위 메모리에는 고유번호가 있다)**를 저장하기 위한 전용 변수입니다.** 메모리의 주소는 집주소처럼 위치정보로 생각할 수 있으므로, 포인터라는 것도 "주소가 적힌 메모지"로 생각할 수 있습니다.

<br>

### 간접지정 연산자(Indirection Operator)

주소 연산(`&`)과 정반대되는 개념의 연산자는 바로 '간접지정 연산자'(`*`)입니다. **여기서 '지정'이라는 말은 임의 대상 메모리에 대한 길이와 해석방법 즉, 자료형을 지정한다는 뜻입니다.** 만일 메모리의 주소가 0x0012FF60인 메모리를 int형으로 지정한다는 뜻은 총 네 바이트의 메모리(각각 주소가 0x0012FF60, 0x0012FF61, 0x0012FF62, 0x0012FF63인 메모리 덩어리)를 한 세트로 보고 int형 변수로 취급한다는 말이 됩니다. (**자료형이란 "일정 길이(혹은 크기)의 메모리에 저장된 정보를 해석하는 방법**")

**간접지정은 변경될 수 있는 임의의 기준주소로 상대적인 메모리의 위치(주소)를 식별하는 방식입니다.**

```c
int x = 10;

// int형에 대한 포인터의 선언 및 정의.
// 포인터 변수(*pnData)는 주소를 저장하기 위한 변수
int *pnData = &x;
print("x : %d\n", x);

// 포인터 변수 pnData에 저장된 주소를 가진 메모리를 int형 변수로 간접지정하고 20을 대입한다.
// 현재 가리키는 대상 메모리는 변수 x의 메모리 주소이므로 x의 값이 20이 된다.
*pnData = 20;
print("x : %d\n", x);

실행결과
10
20
```

`int *pnData = &x;` 에서 pnData의 본질은 int형 변수가 아니라 포인터입니다. 초깃값으로는 이름이 x인 메모리의 주소가 주어졌습니다.

`*pnData = 20;` 에서 가장 먼저 실행되는 식은 *pnData입니다. 이 코드의 의미는 "포인터 변수 pnData에 저장된 주소를 가진 메모리를 int형 변수로 취급"한다는 의미입니다. 주소가 직접 기술된 형식이 아니라 변수에 담긴 주소를 통해 간접적인 방법으로 지정했으니 간접지정입니다.

<br>

### 포인터와 배열

**배열의 이름은 0번 요소의 주소이며, 전체 배열을 대표하는 식별자입니다**. 그리고 포인터 변수는 주소를 저장하기 위한 변수입니다. 이 둘을 조합해서 다음과 같이 추론할 수 있습니다. "**배열의 이름이 주소이므로, 포인터 변수에 저장할 수 있다.**"라고 말이죠. 즉, int형 포인터에 int형 변수의 주소만 담을 수 있는 것이 아니라, int형 배열의 이름도 담을 수 있습니다.

```c
#include <stdio.h>

void main() {
  // int 배열 선언 및 정의.
	int list[5] = { 1, 5, 7, 9, 11 };

  //int에 대한 포인터 변수를 배열의 이름으로 정의한다.
	int *pnData = list;

  *pnData = 3;

	printf("memmory location : %p\n", pnData);
	printf("aList[0] : %d\n", list[0]);

	pnData++;

	printf("memmory location : %p\n", pnData);
	printf("aList[0] : %d\n", *(pnData + 1));
}

실행결과
memmory location : 001DFB58
aList[0] : 3
memmory location : 001DFB5C
aList[0] : 7
```

`int *pnData = list;` 에서는 int형 배열의 이름을 *int에 대한 포인터의 초깃값으로 기술했습니다. 이를 조금 응용하면 pnData = &list[0]으로도 초깃값을 기술할 수 있습니다.

`int *pnData = 3;` 에서 간접지정되는 대상 메모리는 list 배열의 0번 요소입니다. 따라서 list[0] = 3;과 같은 코드입니다. 또한 포인터 변수 pnData에 저장된 주소를 기준으로 오른쪽으로 int 0개 떨어진 위치(주소)의 메모리를 int형 변수로 지정한다는 의미로 *(pnData + 0) 표현할 수 있습니다.

**배열과 포인터가 문법상 호환**되는 이유는 개념적으로나 기술적으로나 사실상 같기 때문입니다. 단지 차이가 있다면 포인터 변수는 말 그대로 변수이고, 배열의 이름은 주소상수라는 것뿐입니다.

`pnData++;` 는 int형 크기만큼 한 칸 이동(주소 증가)를 의미합니다. 단항 증가 연산 후로 주소의 값이 '001DFB58'에서 '001DFB5C'으로 증가한 것을 확인할 수 있습니다. 만약 char형 포인터 변수에 단한 증가 연산을 수행했다면 주소의 값은 char형의 크기인 1byte가 증가했을 것입니다.

아래는 위의 개념을 활용하여 문자 배열을 다루는 예제입니다.

```c
#include <stdio.h>

void main() {
	char chBuffer[20] = { "Hello world!" };

	char *pchData = chBuffer;

	while (*pchData != '\0')
	{		
		printf("%c", *pchData);
		pchData++;
	}
}

실행 결과
Hello world!
```

---

### Reference

독하게 시작하는 C프로그래밍, 루비페이퍼, 최호성