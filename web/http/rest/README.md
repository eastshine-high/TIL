# REST(Web's architectural style)

## REST란 무엇인가.

로이 필딩은 1990년대의 대부분을 HTTP 프로토콜의 버전 1.0(RFC 1945)을 공식화하고, 버전 1.1을 개발(RFC 2616)하며 보냈다. 그 당시 웹은 이미 큰 성공을 거두고 있었고, 그 성공 덕택에 오늘날 우리가 즐기는 수준으로 웹이 성장하기 위해 고쳐야 하는 디자인 문제들이 드러났다.

‘리소스'의 원래 정의는 정적 문서에 초점이 맞춰져 있었다. HTTP에 추가된 인기 있는 ‘쿠키(cookie)’확장(RFC 2109)에 정의됨)은 많은 문제를 일으키고 있었다. 서버는 유효한 HTTP 요청을 받았지만 어떻게 처리해야 할지 모르는 경우도 종종 있었다.

바로 이 지점에서 로이 필딩(Roy Fielding)의 학설이 성과를 올렸다. 필딩 제약 조건과 실제 웹 사이의 격차가 존재한다는 사실이 그의 모델을 쓸모없게 만들지는 않는다. 이런 격차는 문제가 어디 있는지를 지시하는 것이다. 이 문제점들을 고치면 실제 웹은 REST에서 정의한 이상적인 웹에 더 가까이 가게 만들어 준다. 확장성의 문제가 없는 웹이 되는 것이다.

HTTP 1.1(RFC 2616, 1999년)과 URI 표준(RFC 3986)은 이론과 실제상의 대다수의 격차를 고친다. [필딩 제약 조건](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)을 청사진으로 삼아 웹이 고쳐졌다. HTTP 쿠키처럼 고쳐지지 못한 격차들은 여전히 문제로 남아있다.

필딩 논문은 웹과 비슷한 시스템이 가질 특성들을 나열하고 웹을 성공적으로 만들어준 특성들을 고른다. 그 다음 웹처럼 보이는 일반적인 네트워크 시스템을 만들 제약 조건(필딩 제약 조건)을 선택한다. **이 설계 제약 조건(Web's architectural style)의 모음이 REST (REpresentational State Transfer)다.** 웹의 본질을 나타내는 공식적인 구조적 정의다.

REST 뒤에 있는 아이디어가 중요한 이유는 웹 API가 1990년대 중반의 웹과 동일한 위치에 있기 때문이라 생각한다. **확장성과 유지 보수성보다는 편의에 따라 끼워 맞춰진 시스템들이 잔뜩 존재한다. 필딩 제약 조건은 더 나은 세상을 가리키고 있다.** 우리가 가진 웹 API를 이상적인 원칙에 비교해 보면 무엇을 고쳐야 하는지 알 수 있게 된다.

다음은 필딩 제약 조건의 모음이다.

1. Client/Server (클라이언트와 서버 구조)
2. 균일한 인터페이스(Uniform Interface)
3. 계층 시스템(Layered System)
4. 캐시(Cache)
5. 상태 없음(Stateless)
6. 주문형 코드(Code-on-demand, optional)

> [**필딩의 유명한 논문 REST](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)에서는 REST를 다음과 같이 정의한다.**
The Representational State Transfer (REST) style is an abstraction of the architectural elements within a distributed hypermedia system.
이와 관련하여 필딩의 2008년 블로그 글 “[REST API는 하이퍼텍스트 주도여야 한다](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)”도 읽어보길 권장한다.
> 

## 웹의 관점에서 REST

이번에는 **월드 와이드 웹의 관점에서 REpresentational State Transfer(필딩 제약 조건)를 이해보자.** 필딩의 논문은 웹의 설계 뒤의 결정을 설명하고 있지만 “Architecture”는 이런 결정으로부터 나온 세 가지 기술, 즉 HTTP, URL, HTML을 설명한다. 이미 이 기술들을 잘 알고 있겠지만, 필딩 제약 조건과 이 조건들이 어떻게 웹을 성공으로 이끌었는지, 이 제약 조건들을 내 API에 어떻게 활용할 수 있을지를 이해하려면 이 내용을 깊이 이해해야 한다.

이 세 가지(HTTP, URL, HTML) 웹 기술 아래에는 리소스(Resource)와 표현(Representation)이라는 두 가지 필수적인 개념이 있다.

### 리소스(Resource)

사용자가 “무언가에 하이퍼텍스트 링크를 만들거나, 주장을 하거나 반박하거나, 그것의 표현을 받아오거나 캐시를 만들고 싶거나, 다른 표현으로 전체나 일부를 인용하거나, 주석을 달거나, 다른 작업을 취하고 싶다면"(”Architecture”) 그것을 리소스로 만들어야 한다.

**리소스틑 보통 컴퓨터에 저장할 수 있는 무언가다.** 전자 문서, 데이터베이스의 행, 알고리즘 수행 결과 등이다. “Architecture”는 이를 “정보 리소스"라고 부르는데 이것들의 기본 형태가 비트 스트림이기 때문이다. 하지만 리소스는 석류, 사람, 검정색, 용기라는 개념, 엄마와 딸 사이의 관계, 모든 소수의 집합 등 정말 아무것이나 될 수 있다. **유일한 제약 조건이 있는데, 바로 모든 리소스는 URL을 가져야 한다는 것이다.** 웹에서 우리는 URL을 사용해 각 리소스에 전 세계에서 고유한 주소를 부여한다.

### 표현(Representation)은 리소스 상태(State)를 설명한다

클라이언트가 리소스에 GET 요청을 보내면 **서버는 그 리소스를 유용한 방식으로 나타내는 문서를 제공해야 한다. 그게 바로 표현(Representation)이다.** 리소스의 현재 상태를 기계가 읽을 수 있는 설명으로 나타낸 것이다. 석류의 크기와 익은 정도, 데이터베이스 필드에 담긴 데이터 말이다.

서버는 데이터베이스 행을 XML 문서, JSON 객체, CSV, 생성할 때 사용했던 SQL INSERT 문 등으로 나타낼 수 있다. 모두 유효한 표현이다. 클라이언트가 무엇을 요청하느냐에 달려 있을 뿐이다. 석류를 캠으로 찍은 바이너리 이미지로도 표현할 수 있다. **표현(Representation)은 리소스에 대한 어떤 정보든 담을 수 있고, 기계가 읽을 수 있는 어떠한 문서이든 상관없다.**

### 표현의 상태 전송(REpresentational State Transfer)

우리는 표현을 서버가 클라이언트에 보내는 무언가로 생각한다. 그 이유는 우리가 웹 서핑할 때 대부분의 요청이 GET 요청이기 때문이다. 우리가 표현을 요청하고 있는 것이다. 하지만 POST, PUT, PATCH 요청에서는 클라이언트가 서버에 표현을 보낸다(e.g. 게시글 등록). 서버는 받은 요청을 반영하도록 리소스 상태를 변경하는 작업을 수행한다.

**서버는 리소스의 상태를 나타내는 표현을 보낸다. 클라이언트는 그 리소스가 가졌으면 좋을 상태를 설명하는 표현을 보낸다. 이것을 표현의 상태 전송이라 부른다.**

## 참조

<레오나르드 리처드슨 - 마이크 애머슨 - 샘 루비, RESTful Web API, 인사이트>
