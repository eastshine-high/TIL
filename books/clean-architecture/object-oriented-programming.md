# 객체 지향 프로그래밍

**결론**

소프트웨어 아키텍트 관점에서 정답은 명백하다. **OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력**이다.

---

좋은 아키텍처를 만드는 일은 객체 지향(Object Oriented) OO 설계 원칙을 이해하고 응용하는 데서 출발한다.

## 그렇다면 OO란 무엇인가?

이 질문에 대해 누군가는 "데이터와 함수의 조합"이라고 답할 수 있다. 또는 이 질문에 흔히 "실제 세계를 모델링하는 새로운 방법"이라고들 답한다. OO의 본질을 설명하기 위해 세 가지 주문에 기대는 부류도 있는데 , 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism)이 바로 그 주문이다. 이들은 OO가 이 세가지 개념을 적절하게 조합한 것이거나, 또는 OO 언어는 최소한 세 가지 요소를 반드시 지원해야 한다고 말한다.

### 캡슐화?

```
개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화(encapsulation)라고 부른다.

캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.
캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.

<오브젝트, 조영호, 위키북스 (p.20)>
```

OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO가 제공하기 때문이다. 그리고 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이 개념들이 설계 OO언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.

이러한 개념이 OO에만 국한된 것은 아니다. 사실 **C언어에서도 완벽한 캡슐화가 가능하다.** C언어는 데이터 구조(구조체 시그니처)와 함수(함수 시그니처)를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현했다.  여기에서 헤더파일을 include하여 사용하는 측에서 **구조체의 멤버에 접근할 방법은 전혀 없다.**

이후에 **C++**라는 형태로 OO가 등장했고, C가 제공하던 완전한 캡슐화가 깨지게 되었다. C++ 컴파일러는 **기술적인 이유로 클래스와 멤버 변수를 해당 클래스의 헤더 파일에 선언할 것을 요구**했다. 언어에 public, private, protected 키워드를 도입함으로써 불완전한 캡슐화를 사실상 어느 정도 보완하기는 했지만 **사용자는 멤버 변수가 존재한다는 사실 자체를 알게 된다.**

자바와 C#은 헤더와 구현체를 분리하는 방식을 모두 버렸고, 이로 인해 캡슐화는 더욱 심하게 훼손되었다. 이로 인해 캡슐화는 더욱 심하게 훼손되었다. 이들 언어에서는 클래스 선언과 정의를 구분하는 게 아예 불가능하다. 이 때문에 OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.

### 상속?

```
객체 지향에서의 상속(inheritance)은
상위 클래스의 특성을 하위 클래스에서 상속(특성 상속, inheritance)하고 거기에 더해 필요한 특성을 추가, 
즉 확장(extends)해서 사용할 수 있다는 의미다.

여기에 더해 한 가지 재미있는 것은 자바 언어에서 inheritance(상속)라는 키워드는 존재하지 않는다는 것이다.
대신 확장 extends(확장)가 존재한다. 자바 언어 개발팀, 특히 자바 언어의 아버지라고 하는 제임스 고슬링은
객체 지향의 상속을 정확히 이해한 것이다. inheritance가 아닌 extends라는 것을 말이다.

<스프링 입문을 위한 자바 객체 지향의 원리와 이해, 김종민, 위키북스>
```

OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 OO 언어가 확실히 제공했다.  **하지만 상속이란 단순히 어떤 변수와 함수를 유효 범위로 묶어서 재정의하는 일에 불과하다.** 사실상 OO 언어가 있기 훨씬 이전에도 C프로그래머는 언어의 도움 없이 손수 이러한 방식으로 구현할 수 있었다.

C언어에서는 하위 집합(데이터 집합 - 구조체)이 상위 집합에 대응하는 멤버 변수의 순서를 유지하여 마치 하위 집합이 상위 집합으로부터 파생된 구조인 것처럼 상속을 구현한다. 실제로 C++에서는 이 방법을 이용해서 단일 상속을 구현했다.

따라서 OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다고 말할 수 있다. 하지만 이렇게 말하는 데는 어폐가 있다. 상속을 흉내내는 요령은 있었지만, 사실상 상속만큼 편리한 방식은 절대 아니기 때문이다. 게다가 이 기법을 이용해서 다중 상속(자바에서는 다중 상속을 지원하지는 않는다)을 구현하기란 훨씬 더 어려운 일이었다.

**따라서 OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수는 있다.**

### 다형성?

 OO 언어가 있기 이전에 C언어를 통해서도 다형성을 표현할 수 있었다.

 C언어의 stdio를 보면 getchar() 함수는 다형적이라 볼 수 있다. 즉, 행위가 STDIN의 타입에 의존한다. C 프로그램에서는 인퍼테이스가 없다. 그러면 getchar() 함수를 호출할 때 도대체 어떤 방식으로 문자를 읽는 장치 드라이버를 호출할 수 있을까? 대답은 간단하다. 유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 다섯 가지 표준 함수를 제공할 것을 요구한다. 열기(open), 닫기(close), 읽기(read), 쓰기(write), 탐색(seek)이 바로 이 표준 함수들이다. FILE 데이터 구조체는 이들 다섯 함수를 가리키는 포인터들을 포함한다. **다시 말해 getchar()는 STDIN이라는 변수명으로 참조되는  FILE* 데이터 구조체의 read 포인터가 가리키는 함수를 단순히 호출할 뿐이다.**

 이처럼 단순한 기법이 모든 OO가 지닌 다형성의 근간이 된다. **즉 함수를 가리키는 포인터를 응용한 것이 다형성이라는 점**이다. 1940년대 후반 폰 노이먼 아키텍처가 처음 구현된 이후 프로그래머는 다형적 행위를 수행하기 위해 함수를 가리키는 포인터를 사용해 왔다. 따라서 OO가 새롭게 만든 것은 전혀 없다. 다만 OO 언어는 다형성을 좀 더 안전하고 편리하게 사용할 수 있게 해준다.

 함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데, 함수 포인터는 위험하다는 사실이다. 만약 프로그래머가 포인터 사용에서 실수를 하게 되면 버그가 발생하고 이러한 버그는 찾아내고 없애기가 지독히도 힘들다. OO 언어는 이런 실수할 위험이 없다. OO 언어를 사용하면 다형성은 대수롭지 않은 일이 된다. 이러한 이유로 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

**다형성이 가진 힘**

다형성이 뭐가 그렇게 좋은가? 다형성이 가진 매력의 진가를 알아보기 위해 복사 프로그램을 생각해 보자.

 새로운 입출력 장치가 생긴다면 복사 프로그램에는 어떤 변화가 생기는가? 아무런 변경도 필요치 않다. 심지어 복사 프로그램을 다시 컴파일할 필요 조차 없다. 왜냐면 복사 프로그램의 소스 코드는 입출력 드라이버의 소스 코드에 의존하지 않기 때문이다. 

다시 말해 입출력 드라이버가 복사 프로그램의 플러그인이 된 것이다. 왜 유닉스 운영체제는 입출력 장치들을 플로그인 형태로 만들었을까? 1950녀대 후반에 프로그램이 장치 독립적이어야 한다는 사실을 이미 배웠기 때문이다. 당시 장치에 의존적인 수 많은 프로그램을 만들고 나서야, 이들 프로그램이 다른 장치에서도 동일하게 동작할 수 있도록 만드는 것이 우리가 진정 바라던 일임을 깨달았다. 

 **플러그인 아키텍처(plugin architecture)**는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다. 그럼에도 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문이었다. 

 **OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.**

### 의존성 역전

다형성을 안전하고 편리하게 적용하기 이전에는 **전형적인 호출 트리의 경우** main 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며 중간 수준 함수는 다시 저수준 함수를 호출한다. **이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.**

이러한 제약 조건으로 인해 소프트웨어 아키텍트에게 남은 선택지는 별로 없었다. 즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.

**하지만 다형성이 끼어들면 무언가 특별한 일이 일어난다. 그림 5.2(본서 참고)에서 HL1 모듈은 ML1 모듈의 F()함수를 호출한다. 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런터임에는 존재하지 않는다. HL1은 단순히 ML1 모듈의 함수 F()를 호출할 뿐이다. 하지만 ML1과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어 흐름과는 반대인 점을 주목하자. 이는 의존성 역전(dependency inversion)이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.** 

OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다. 이러한 소스 코드 의존성은 소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.

이러한 접근법을 사용한다면, OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다. 이것이 바로 OO가 제공하는 힘이다. 그리고 이것이 바로 OO가 지향하는 것이다.(최소한 아키텍트의 관점에서는)

---

**참조**

<로버트 C. 마틴, 클린 아키텍처, 인사이트>
