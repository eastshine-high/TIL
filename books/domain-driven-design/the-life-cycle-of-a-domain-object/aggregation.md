## AGGREGATE(집합체)

모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지 않다. 그 까닭은 단지 개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다. 그렇다고 변경의 일관성을 보장하고자 신중 잠금 기법(cautious locking scheme)을 쓴다면 다수의 사용자가 서로 부적절하게 간섭해서 시스템이 사용할 수 없는 상태가 될 것이다.

이러한 문제가 데이터베이스 트랜잭션과 관련된 기술적 문제로 나타나더라도 문제의 근원은 모델에 경계가 정의돼 있지 않다는 데 있다. 모델을 근간으로 하는 해법을 이용하면 모델을 좀 더 이해하기 쉬워지고 설계하는 바가 더 쉽게 전달될 것이다. 모델이 개선됨에 따라 해당 모델이 구현을 어떻게 바꿔야 할지 안내할 것이다.

먼저 우리는 모델 내의 참조에 대한 캡슐화를 추상화할 필요가 있다. **`AGGREGATE`는 우리가 데이터 변경의 단위로 다루는 연관 객체의 묶음을 말한다.** 각 AGGREGATE에는 루트(root)와 경계(boundary)가 있다. 경계는 AGGREGATE에 무엇이 포함되고 포함되지 않는지를 정의한다. 루트는 단 하나만 존재하며, AGGREGATE에 포함된 특정 ENTITY를 가리킨다. 경계 안의 객체는 서로 참조할 수 있지만, 경계 바깥의 객체는 해당 AGGREGATE의 구성요소 가운데 루트만 참조할 수 있다. 루트 이외의 ENTITY는 지역 식별성(local identity)을 지니며, 지역 식별성은 AGGREGATE 내에서만 구분되면 된다. 이는 해당 AGGREGATE의 경계 밖에 위치한 객체는 루트 ENTITY의 컨텍스트 말고는 AGGREGATE의 내부를 볼 수 없기 때문이다.

**불변식**은 데이터가 변결될 때마다 유지돼야 하는 일관성 규칙을 뜻하며, 여기엔 AGGREGATE 구성하는 각 구성요소 간의 관계도 포함될 것이다. 그러나 여러 AGGREGATE에 걸쳐 존재하는 규칙이 언제나 최신 상태로 유지되는 것은 아니다. 다른 의존 관계는 이벤트 처리, 배치 처리, 혹은 다른 갱신 메커니즘을 토대로 특정 시간 내에 해결될 수 있다. 반면, 한 AGGREGATE에 적용된 불변식은 각 트랜잭션이 완료될 때 이행될 것이다.

이제 그러한 개념적 AGGREGATE를 구현하려면 모든 트랜잭션에 적용되는 다음과 같은 규칙이 필요하다.

- 루트 ENTITY는 전역 식별성을 지니며 궁극적으로 **불변식을 검사할 책임**이 있다.
- 각 루트 ENTITY는 전역 식별성을 지닌다. 경계 안의 ENTITY는 지역 식별성을 지니며, 이러한 지역 식별성은 해당 AGGREGATE 안에서만 유일하다.
- **AGGREGATE의 경계 밖에서는 루트 ENTITY를 제외한 AGGREGATE 내부의 구성요소를 참조할 수 없다.** 루트 ENTITY가 내부 ENTITY에 대한 참조를 다른 객체에 전달해 줄 수는 있지만 그러한 객체는 전달받은 참조를 일시적으로만 사용할 수 있고, 참조를 계속 보유하고 있을 수는 없다. 루트는 VALUE OBJECT의 복사본을 다른 객체에 전달해 줄 수 있으며, 복사본에서는 어떤 일이 일어나든 문제되지 않는다. 이것은 복사본이 단순한 VALUE에 불과하며 AGGREGATE와는 더는 연관관계를 맺지 않을 것이기 때문이다(데이터 오너쉽으로 이해할 수 있겠다).
- 지금까지의 규칙을 바탕으로 결론을 내려보면 데이터베이스 질의를 이용하면 AGGREGATE의 루트만 직접적으로 획득할 수 있다. 다른 객체는 모두 AGGREGATE를 탐색해서 발견해야 한다.
- AGGREGATE 안의 객체는 다른 AGGREGATE의 루트만 참조할 수 있다.
- 삭제 연산은 AGGREGATE 경계 안의 모든 요소를 한 번에 제거해야 한다.(가비지 컬렉션을 이용하면 이렇게 하기가 쉬운데, 루트를 제외한 나머지 구성요소는 외부에서 그것을 참조하지 않을 경우 루트가 삭제되면 가비지 컬렉터가 자동으로 그것들을 모두 수집할 것이기 때문이다.)
- AGGREGATE 경계 안의 어떤 객체를 변경하더라도 전체 AGGREGATE의 불변식은 모두 지켜져야 한다.

ENTITY와 VALUE OBJECT를 AGGREGATE로 모으고 각각에 대해 경계를 정의하라. 한 ENTITY를 골라 AGGREGATE의 루트로 만들호 AGGREGATE 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게 하라. AGGREGATE 밖의 객체는 루트만 참조할 수 있게하라. 내부 구성요소에 대한 일시적은 참조는 단일 연산에서만 사용할 목적에 한해 외부로 전달될 수 있다. 루트를 경유하지 않고는 AGGREGATE의 내부를 변경할 수 없다. 이런 식으로 AGGREGATE의 각 요소를 배치하면 AGGREGATE 안의 객체와 전체로서의 AGGREGATE의 상태를 변경할 때 모든 불변식을 효과적으로 이행할 수 있다.

AGGREGATE는 생명주기의 전 단계에서 불변식이 유지돼야 할 범위를 표시해준다. 이어지는 패턴인 FACTORY와 REPOSITORY는 AGGREGATE를 대상으로 연산을 수행하며, 특정 생명주기 전이에 따르는 복잡성을 캡슐화한다.

## 참조

<에릭 에반스, 도메인 주도 설계, 위키북스>
