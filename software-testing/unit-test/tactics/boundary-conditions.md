# The CORRECT Way : Boundary Conditions

단위 테스트는 종종 경계 조건들에 관계된 결함들을 미연에 방지하는 데 도움이 됩니다. 경계 조건은 행복 경로의 끝에 있는 것으로  자주 문제가 발생합니다. `CORRECT` 약어로 그 조짐을 알아낼 수 있었으며, 이 약어는 단위 테스트를 만들 때 고려해야 할 경계 조건들을 생각하는 데도 도움이 됩니다.

- [C]onformance(준수) : 값이 기대한 양식을 준수하고 있는가?
- [O]rdering(순서) : 값의 집합이 적절하게 정렬되거나 정렬되지 않았나?
- [R]ange(범위) : 이성적인 최솟값과 최댓값 안에 있는가?
- [R]eference(참조) : 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
- [E]xistence(존재) 값이 존재하는가(널이 아니거나(non-null), 0이 아니거나(nonzero), 집합에 존재하는가 등)?
- [C]ardinality(기수) : 정확히 충분한 값들이 있는가?
- [T]ime(절대적 혹은 상대적 시간) : 모든 것이 순서대로 일어나는가? 정확한 시간에? 정시에?

각 CORRECT 조건에 대해 넘겨진 인수, 필드와 지역적으로 관리하는 변수들까지 가능한 모든 발생 원인이 데이터에 미칠 영향을 고려하세요. 다음 질문에 완전히 대답할 수 있어야 합니다. **그 밖의 문제될 것이 있는가?**

**잘못될 수 있는 어떤 것이라도 떠오르면 테스트 이름을 적어 놓으세요.** 그리고 시간이 있다면 테스트에 살을 붙이세요. 한 가지 가능한 오류 시나리오를 생각해 두면 종종 연계되는 다른 시나리오도 떠올릴 수 있습니다. 테스트에 대해 가능한 오랫동안 상상력을 유지해 보세요.

### [C]onformance(준수)

많은 데이터 요소가 특정 약식을 따라야 합니다. 예를 들어 이메일 주소는 일반적으로 다음과 같은 형식입니다.

`name@somedomain`

이메일 주소, 전화번호, 계좌 번호, 파일 이름 등 양식 있는 문자열 데이터를 검증할 때는 많은 규칙이 필요합니다. 하지만 보통 단순합니다. 좀 더 복잡한 구조의 데이터의 경우 테스트 케이스를 조합하면 그 수가 폭발적으로 늘어나기도 합니다.

헤더 기록, 몇 개의 데이터 기록과 트레일러 기록으로 구성된 보고 자료를 읽는다고 합시다 테스트해야 할 경계 조건은 다음과 같습니다.

- 헤더가 없습니다. 데이터와 트레일러만 존재합니다.
- 데이터가 없습니다. 헤더와 트레일러만 존재합니다.
- 트레일러가 없습니다. 헤더와 데이터만 존재합니다.
- 트레일러만 있습니다.
- 헤더만 있습니다.
- 데이터만 있습니다.

기대하는 구조에 입력 데이터가 맞는지 확인해 볼 수 있는 방법을 더 많이 브레인스토밍하면 더욱더 잘할 수 있습니다. 그렇다면 언제 테스트 작성을 중단해야 할까요?

계좌 번호 같은 필드는 시스템에 있는 수많은 메서드에 넘겨질 것입니다. 하지만 시스템에 그 필드가 처음 입력될 때 검증한다면(아마도 UI를 사용하여 공개적으로 노출된 API 인자로 쓰거나 파일에서 읽을 때) 그 필드를 인자로 넘길 때마다 검사하지 않아도 됩니다. 이처럼 시스템의 데이터 흐름을 이해하면 불필요한 검사를 최소화할 수 있습니다.

### [O]rdering(순서)

데이터 순서 혹은 커다란 컬렉션에 있는 데이터 한 조각의 위치는 코드가 쉽게 잘못될 수 있는 CORRECT 조건에 해당합니다.

예를 들어 다음의 프로파일의 서열을 만드는 코드는 테스트가 실패할 수 있습니다.

```java
public List<Profile> ranked() {
		Collections.sort(profiles, 
				(p1, p2) -> ((Integer)p1.score()).compareTo(p2.score()));
		return profiles;
}
```

순서가 반대였기 때문입니다. 테스트를 통과하려면 compareTo 메서드에 넘기는 변수르 p1이 아닌 p2를 수신자로 해야 합니다.

### [R]ange(범위)

자바 기본형으로 변수를 만들 때 대부분은 필요한 것보다 훨씬 많은 용량을 가집니다. 기본형의 과도한 사용에 대한 코드 냄새를 기본형 중독(primitive obsession)이라고 합니다. 자바 같은 객체 지향 언어의 장점은 사용자 정의 추상화를 클래스로 만들 수 있다는 것입니다.

원은 360도입니다. 이동 방향을 자바 기본형으로 저장하기 보다 **Bearing 클래스로 범위를 제약하는 로직을 캡슐화할 수 있습니다.** 제약 사항은 Bearing 클래스의 생성자에 구현되어 있습니다.

```java
public class Bearing {
	public static final int MAX = 359;
	private int value
	
	public Bearing(int value) {
		if(value < 0 || value > MAX) throw new BearingOutOfRangeException();
		this.value = value;
	}

	...
}
```

### [R]eference(참조)

어떤 메서드를 테스트할 때는 다음을 고려해야 합니다.

- 범위를 넘어서는 것을 참조하고 있지 않은지
- 외부 의존성은 무엇인지
- 특정 상태에 있는 객체를 의존하고 있는지 여부
- 반드시 존재해야 하는 그 외 다른 조건들

예를 들어, 고객의 계정 히스토리를 표시하는 웹 앱은 고객이 먼저 로그인해야 합니다. 스택의 pop() 메서드를 호출할 때는 스택이 비어 있으면 안 됩니다. 차량의 변속기를 주행에서 주차로 변경할 때는 먼저 차를 멈추어야 합니다. 변속기를 주행 중에 변경할 수 있다면 자동차에 심각한 피해가 발생할 것입니다.

### [E]xistence(존재) 값이 존재하는가

스스로에게 “주어진 값이 존재하는가?”라고 물어봄으로써 많은 잠재적인 결함을 발견할 수 있습니다. 어떤 인자를 허용하거나 필드를 유지하는 메서드에 대해 그 값이 null, 0 혹은 비어 있는 경우라면 어떤 일이 일어날지 생각해 보세요.

프로그래머로서 보통 행복 경로를 만드는 데 무엇보다 주력합니다. 예상하는 데이터가 없을 때 발생하는 불행 경로는 그 다음에 생각하고는 합니다. 잠재적인 지옥으로 향하는 고속도로처럼 테스트를 추가하고 싶다면 호출된 메서드가 null을 반환하거나. 기대하는 파일이 없거나, 네트워크가 다운되었을 때 어떤 일이 일어나는지 확인하는 테스트를 작성하세요.

### [C]ardinality(기수)

많은 프로그래머가 숫자 세기에 능하지 않습니다. 특히 손가락이 더 이상 도와줄 수 없는 열 개 이상은 말이죠. 다음 질문에 대해 손가락, 종이, 구글의 도움을 받지 않고 머릿속에서 바로 답변해 보세요.

일직선으로 뻗은 길이가 12미터인 곳에 울타리를 몇 개 세워야 합니다. 각 울타리 영역은 3미터이고, 각 영역의 끝에도 울타리 기둥을 세워야 하니다. 울타리 기둥은 몇 개 필요할까요?

여기서 우리는 4라고 대답을 했을 수도 있습니다. 문제에 대해 충분히 생각하지 않아서 오류들이 발생할 수 있습니다(정답은 5). 이것을 ‘울타리 기둥 오류’라고 합니다.

울타리 기둥 오류는 한 끗 차이로 발생하는 수많은 경우 중 한 가지를 의미하며, 종종 한곳 혹은 다른 곳에서 치명적인 상태가 되고는 합니다. 개수를 어떻게 잘 세어 테스트할지 고민해 보고, 얼마나 많은지 확인해 보세요. [E]xistence는 기술적으로 기수(cardinality)의 특수한 경우입니다.

### [T]ime

시간에 관하여 마음에 담아 두어야 할 측면 몇 개는 다음과 같습니다.

- 상대적 시간(시간 순서)
- 절대적 시간(측정된 시간)
- 동시성 문제들

어떤 인터페이스들은 태생적으로 상태를 가지고 있습니다. login()은 logout()메서드에 앞서 호출되어야 합니다. 이처럼 read()에 앞서 open() 메서드를 호출해야 하고, close()에 앞서 read() 메서드를 호출해야 하는 등입니다.

메서드들의 호출 순서가 맞지 않았을 때 어떤 일이 일어날지 생각해 봅시다. 다양한 대안 순서를 시도해 보세요. 상대적인 시간은 타임아웃 문제도 포함할 수 있습니다. 수명이 짧은 자원에 대해 코드가 얼마나 기다릴 수 있는지 결정해야 합니다.

## 참조

<제프 랭어 외, 자바와 JUnit을 활용한 실용주의 단위테스트, 길벗>
