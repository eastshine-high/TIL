# The Right-BICEP : What to Test

메서드 혹은 클래스의 코드를 보았을 때 숨어 있는 모든 버그를 찾아내는 것은 불가능합니다. 경험이 쌓이면 느낌만으로도 어디에 문제가 있는지 찾아 집중해서 테스트할 수 있습니다. 그렇게 하기까지 가능한 실패 사례를 발견해 내는 것은 쉽지 않아 보입니다. 최종 사용자는 우리 버그를 꽤 잘 찾아내지만, 이러한 상황은 우리 경력에는 도움이 되지 않습니다. **우리에게 필요한 것은 무엇을 테스트하는 것이 중요한 지 도와줄 수 있는 지침입니다.**

`Right-BICEP`은 무엇을 테스트할지에 대해 쉽게 선별하게 합니다.

- Right : 결과가 올바른가?
- B : Boundary conditions(경계 조건)은 맞는가?
- I : Inverse relationship(역 관계)를 검사할 수 있는가?
- C : 다른 수단을 활용하여 Cross-check(교차 검사)할 수 있는가?
- E : Error conditions(오류 조건)을 강제로 일어나게 할 수 있는가?
- P : Perfromance characteristics(성능 조건)은 기준에 부합하는가?

### Right : 결과가 올바른가?

**테스트 코드는 무엇보다도 먼저 기대한 결과를 산출하는지 검증할 수 있어야 합니다.** 아래의 산술 평균 테스트는 ScoreCollection 클래스가 5와 7을 넣었을 때 평균으로 6을 반환하는지 보여줍니다.

```java
@Test
   public void answersArithmeticMeanOfTwoNumbers() {
      ScoreCollection collection = new ScoreCollection();
      collection.add(() -> 5);
      collection.add(() -> 7);
      
      int actualResult = collection.arithmeticMean();
      
      assertThat(actualResult, equalTo(6));
   }
```

하지만 **이러한 테스트는 행복 경로 테스트의 영역에 해당**합니다. 소프트웨어의 **최종 사용자의 목표를 반영하는 긍정적인 사례이지만 전체에 비해서는 작은 부분**입니다.

행복 경로 테스트는 중요한 다음 질문에서 한 가지 답변을 나타냅니다.

> 나는 코드가 정상적으로 동작한다면, 그것을 알 수 있을까?
> 

**다른 관점으로, 어떤 작은 부분의 코드에 대해 행복 경로 테스트를 할 수 없다면 그 내용을 완전히 이해하지 못한 것입니다. 그리고 앞의 질문에 대답할 수 있을 때까지 잠시 추가 개발은 보류하면 좋습니다.**

“잠시만, 글새요. 모든 요구 사항을 알 수 있다고 주장하는 것은 현실적이지 않습니다. 요구 사항이 모호하거나 불완전하다면요? 그러면 모든 요구 사항이 확정될 때까지 개발을 멈추어야 하나요?”

모든 질문에 대답할 수 있을 때까지 기다릴 필요는 없습니다. 이것에 대해 최선의 판단을 하고 나중에 답변이 명확해졌을 때 개선하면 됩니다. 대부분은 어떻게든 변경이 일어납니다. 고객이 생각을 바꾸거나 어떤 사람은 다른 답변을 요구하는 어떤 것을 배우기도 합니다.

여러분이 작성하는 단위 테스트는 선택을 문서화합니다. 어떤 변경이 발생하면 적어도 현재까지 코드가 어떻게 동작했는지는 알게 됩니다.

### B : Boundary conditions(경계 조건)은 맞는가?

코드에 있는 분명한 행복 경로는 입력 값의 양극단을 다루는 코드 시나리오의 경계 조건에 걸리지 않을 수도 있습니다. 여러분이 마주치는 **수많은 결함은 이러한 모서리 사례(corner case)이므로 테스트로 이것들을 처리해야 합니다.**

생각해야 하는 경계 조건은 다음과 같습니다.

- 모호하고 일관성 없는 입력 값, e.g. 특수 문자`(”!*W:X\&*Gi/w$→$G/h#W@)`가 포함된 파일 이름
- 잘못된 양식의 데이터, e.g. 최상위 도메인이 빠진 이메일 주소 (`ozil@foobar.`)
- 수치적 오버플로를 일으키는 계산
- 비거나 빠진 값, e.g. `0.0.0`, `“”` 혹은 `null`
- 이성적인 기댓값을 훨씬 벗어나는 값, 예를 들어 150세의 나이
- 교실의 당번표처럼 중복을 허용해서는 안 되는 목록에 중복 값이 있는 경우
- 정렬이 안 된 정렬 리스트 혹은 그 반대. 정렬 알고리즘에 이미 정렬된 입력 값을 넣은 경우나 정렬 알고리즘에 역순 데이터를 넣는 경우
- 시간 순이 맞지 않는 경우. e.g. HTTP 서버가 OPTIONS 메서드의 결과를 POST 메서드보다 먼저 반환해야 하지만 그 후에 반환하는 경우

### I : Inverse relationship(역 관계)를 검사할 수 있는가?

**때때로 논리적인 역 관계를 적용하여 행동을 검사할 수 있습니다.** 종종 수학 계산에서 사용합니다. 곱셈으로 나눗셈을 검증하고 뺄셈으로 덧셈을 검증하는 것처럼 말입니다.

우리는 뉴턴의 알고리즘을 활용하여 제곱근을 구합니다. 어떤 숫자의 제곱근을 유도하고 그 결과를 제곱하면(즉, 자기 자신을 곱하면) 우리가 시작했던 것과 같은 숫자를 얻어야 함을 기억할 것입니다.

테스트에서는 250을 인자로 Newton.squareRoot() 메서드를 호출하여 Result 변수에 저장합니다. 단언에서는 Result 값을 (그것이 무엇이든 우리가 알아야 할 필요는 없지만) 제공하여 원래의 250에 충분히 가까운지 검사합니다.

교차 검사는 모든 요소를 더하고 균형이 맞는지 확인하는 방법으로, 복식 부기(회계 장부의 차변(Debit) 금액 합계와 대변(Credit) 금액 합계가 항상 같아야 한다)에서 총 계정 원장을 맞추는 것과 같습니다.

### C : 다른 수단을 활용하여 Cross-check(교차 검사)할 수 있는가?

흥미로운 **문제에는 무수한 해법이 존재합니다.** 여러분은 그중 성능이 좋거나 냄새가 좋기 때문에 1등 해법을 선택합니다. 그러면 프로덕션 결과를 교차 검사하기 위해 ‘패배자' 해법이 남습니다. 아마도 프로덕션 시스템에 활용하기에는 너무 느리거나 유연하지 않겠지만, 그것들이 믿을 수 있고 참값을 보장한다면 1등 해법을 교차 검사할 때 활용할 수 있습니다.

**교차 검사를 위해 ‘좀 떨어지는' 제곱근의 자바 라이브러리를 사용할 수 있습니다**(명백히 나쁜 자아 때문에 고통받고 있습니다). 새롭고 대단히 멋진 제곱근 로직이 Math.sqrt() 메서드와 동일한 결과를 내는지 확인합니다.

```java
assertThat(Newton.squareRoot(1969.0),
						closeTo(Math.sqrt(1969.0), Newton.TOLERANCE));
```

교차 검사를 보는 다른 방법은 클래스의 서로 다른 조각 데이터를 사용하여 모든 데이터가 합산되는지 확인해 보는 것입니다.

### E : Error conditions(오류 조건)을 강제로 일어나게 할 수 있는가?

**행복 경로가 있다는 것은 반대로 불행한 경로도 있다는 것을 의미합니다.** 오류가 절대로 발생할 수 없다고 생각할 수도 있습니다. 디스크가 꽉 차거나, 네트워크 선이 떨어지거나, 이메일이 블랙홀에 빠지고 프로그램이 중단될 수 있습니다. 여러분은 테스트 코드로 이러한 모든 실전 문제를 우아하고 이성정인 방식으로 다루기 원할 것입니다. 그렇게 하려면 **테스트도 오류들을 강제로 발생시켜야 합니다.**

코드를 테스트하기 위해 도입할 수 있는 오류의 종류 혹은 다른 환경적인 제약 사항들을 생각해 봅시다. 다음은 고려해야 할 몇 가지 시나리오입니다.

- 메모리가 가득 찰 때
- 디스크 공간이 가득 찰 때
- 벽시계 시간에 관한 문제들(e.g. 서버와 클라이언트 간 시간이 달라서 발생하는 문제들)
- 네트워크 가용성 및 오류들
- 시스템 코드
- 제한된 생상 팔레트
- 매우 높거나 낮은 비디오 해상도

좋은 단위 테스트는 단지 코드에 존재하는 로직 전체에 대한 커버리지를 달성하는 것이 아닙니다. 때때로 뒷주머니에서 작은 창의력을 꺼내는 노력이 필요합니다. 가장 끔직한 결함들은 종종 전혀 예상하지 못한 곳에서 나옵니다.

### P : Perfromance characteristics(성능 조건)은 기준에 부합하는가?

구글의 롭 파이크(Rob Pike)는 “병목 지점(bottleneck)은 놀라운 곳에서 일어납니다. 따라서 실제로 병목이 어디인지 증명되기 전까지는 미리 짐작하여 코드를 난도질하지 마세요.”라고 말합니다. 정말 많은 프로그래머가 성능 문제가 어디에 있으며 최적의 해법이 무엇인지 추측합니다. 유일한 문제점은 이러한 추측이 종종 잘못되었다는 것입니다.

추측만으로 성능 문제에 바로 대응하기보다는 단위 테스트를 설계하여 진짜 문제가 어디에 있으며 예상한 변경 사항으로 어떤 차이가 생겼는지 파악해야 합니다.

성능이 핵심 고려 사항이라면 단위 테스트보다는 좀 더 고수준에서 문제에 집중하고 싶을 것이고, JMeter 같은 도구를 사용하길 원할 수도 있습니다. 여전히 단위 수준 성능 측정에 관심이 많다면 JUnitPerf 같은 서드파티 도구를 찾아도 됩니다.

### 정리

`Right-BICEP` 암기법을 활용하여 활용하여 행복 경로, 경계 조건과 오류 조건을 다루는 테스트를 작성해야 함을 기억할 것입니다. 또 결과를 교차 검사하고 역 관계를 살펴보며 테스트 코드의 유효성을 강화할 수 있다는 것도 배웟습니다 .그리고 언제 코드의 성능을 보는 것이 유용한지도 알았습니다.

## 참조

<제프 랭어 외 2, 자바와 JUnit을 활용한 실용주의 단위테스트, 길벗>
