## 예외를 처리하는 일반적인 방법은 크게 세 가지가 있다.

- 예외 복구 : 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법.
- 예외처리 회피 : 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 방법.
- 예외 전환 : 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던지는 방법.

<br>

### 예외 복구

**예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법이다.** 예를 들어 사용자가 요청한 파일을 읽으려고 시도했는데 해당 파일이 없다거나 다른 문제가 있어서 읽히지가 않아서 IOException이 발생했다고 생각해보자. 이때는 **사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내**해서 예외상황을 해결할 수 있다. **예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도해주는 것**이다. 이런 경우 예외상황은 다시 정상으로 돌아오고 예외를 복구했다고 볼 수 있다. 

또 다른 예로, **네트워크 접속이 원활하지 않아서 예외가 발생했다면 일정 시간 대기했다가 다시 접속을 시도해보는 방법**을 사용해서 예외상황으로부터 복구를 시도할 수 있다. 물론 정해진 횟수만큼 재시도해서 실패했다면 예외 복구는 포기해야 한다.

**예외처리 코드를 강제하는 체크 예외들은 이렇게 예외를 어떤 식으로든 복구할 가능성이 있는 경우에 사용한다.** API를 사용하는 개발자로 하여금 예외상황이 발생할 수 있음을 인식하도록 도와주고 이에 대한 적절한 처리를 시도해보도록 요구하는 것이다.

<br>

### 예외처리 회피

**예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 방법이다.** throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch 문으로 일단 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는(rethrow) 것이다.

JdbcContext나 JdbcTemplate이 사용하는 콜백 오브젝트는 메소드 선언을 보면 알겠지만 ResultSet이나 PreparedStatement 등을 이용해서 작업하다 발생하는 SQLException을 자신이 처리하지 않고 템플릿으로 던져버린다. 콜백 오브젝트의 메소드는 모두 throws SQLException이 붙어 있다. SQLException을 처리하는 일은 콜백 오브젝트의 역할이 아니라고 보기 때문이다. 콜백 오브젝트의 메소드는 SQLException에 대한 예외를 회피하고 템플릿 레벨에서 처리하도록 던져준다.

**하지만 콜백과 템플릿처럼 긴밀하게 역할을 분담하고 있는 관계가 아니라면 자신의 코드에서 발생하는 예외를 그냥 던져버리는 건 무책임한 책임회피일 수 있다.** 만약 DAO가 SQLException을 생각 없이 던져버리면 어떻게 될까? 아마도 이런 경우라면 DAO에서 던진 SQLException을 서비스 계층 메소드가 다시 던지고, 컨트롤러도 다시 던지도록 선언해서 예외는 그냥 서버로 전달되고 말 것이다.

**예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.** 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야 한다.

<br>

### 예외 전환

예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외 메소드를 밖으로 던지는 것이다. 하지만 **예외 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던지는 방법이다.** 예외 전환은 보통 두 가지 목적으로 사용된다.

**첫째는 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우**에, 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서다. API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것이다.

예를 들어 새로운 사용자를 등록하려고 시도했을 때 아이디가 같은 사용자가 있어 DB 에러가 발생하면 JDBC API는 SQLException을 발생시킨다. 이 경우 DAO 메소드가 SQLException을 그대로 밖으로 던져버리면, DAO를 이용해 사용자를 추가하려고 한 서비스 계층 등에서는 왜 SQLException이 발생했는지 쉽게 알 방법이 없다. 로그인 아이디 중복 같은 경우는 충분히 예상 가능하고 복구 가능한 예외상황이다. 이럴 땐 DAO에서 SQLException의 정보를 해석해서 DuplicateUserIdException 같은 예외로 바꿔서 던져주는 게 좋다.

**두 번째** 전환 방법은 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap)하는 것이다. 첫 번째 목적에서와 같이 중첩 예외(nested exception)를 이용해 새로운 예외를 만들고 원인(cause)이 되는 예외를 내부에 담아서 던지는 방식은 같다. 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니라 **주로 예외처리를 강제하는 체크 예외를 언체크 런타임 예외로 바꾸는 경우에 사용**한다. 일반적으로 체크 예외를 계속 throws를 사용해 넘기는 건 무의미하다.

대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 잇는 기능을 제공한다. 어차피 복구하지 못할 예외라면 애플리케이션 코드에서는 런타임 예외로 포장해서 던져버리고, 예외처리 서비스 등을 이용해 자세한 로그를 남기고, 관리자에게는 메일 등으로 통보해주고, 사용자에게는 친절한 안내 메시지를 보여주는 식으로 처리하는 게 바람직하다.

<br>

### Cf. 중첩 예외(nested exception)

보통 전환하려는 예외에 원래 발생한 예외를 담아서 중첩예외로 만드는 것이 좋다. 중첩 예외는 getCause() 메소드를 이용해서 처음 발생한 예외가 무엇인지 확인할 수 있다. 중첩 예외는 아래 예시처럼 새로운 예외를 만들면서 생성자나 initCause() 메소드로 근본 원인이 되는 예외를 넣어주면 된다.

```java
// 1. 생성자를 이용
catch(SQLException e) {
	...
	throw DuplicateUserIdException(e);
}

// 2. initCause 메서드를 이용
catch(SQLException e) {
	...
	throw DuplicateUserIdException().initCause(e);
}
```

<br>

### Reference

<토비의 스프링 3.1, 이일민, 에이콘>
