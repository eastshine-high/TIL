# 스트림(stream)

스트림이란 정확히 뭘까? 스트림이란 ‘**데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소(Sequence of elements)**’로 정의할 수 있다. 이 정의를 하나씩 살펴보자.

- 소스 : **스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.** 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다. 즉, 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.
- 연속된 요소 : 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다. ‘**연속된(sequenced)이라는 표현은 순서와 상관없이 아무 값에나 접근하는 것이 아니라 순차적으로 값에 접근한다는 것**을 의미한다.
- 데이터 처리 연산 : **스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.** 예를 들어 `filter`, `map`, `reduce`, `find`, `match`, `sort` 등으로 데이터를 조작할 수 있다. 스트림 연산은 순차적으로 또는 병렬로 실행할 수 잇다.

또한 스트림에는 다음과 같은 두 가지 중요 특징이 있다.

- 파이프라이닝(Pipelining) : **대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다.** 그 덕분에 게으름(laziness), 쇼트서킷(short-circuiting)같은 최적화도 얻을 수 있다. 연산 파이프라인은 데이터 소스에 적용하는 데이터베이스 질의와 비슷하다.
- 내부 반복(internal iteration) : 반복자를 이용해서 사용자가 명시적(for-each 등을 사용)으로 반복(외부 반복, external iteration)하는 컬렉션과 달리 **스트림**은 내부 반복을 지원한다. 따라서 반복 과정을 신경 쓰지 않아도 된다. 하지만 이와 같은 이점을 누리려면 (filter나 map 같이) 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 한다.

지금까지 설명한 내용을 예제로 확인하자.

```java
import static java.util.stream.Collectors.toList;
List<String> threeHighCaloricDishNames = 
        menu.strema()
                .filter(dish -> dish.getCalories() > 300)
                .map(Dish::getName)
                .limit(3)
                .collect(toList());
System.out.println(threeHighCaloricDishNames);
```

우선 요리 리스트를 포함하는 menu에  stream 메서드를 호출해서 스트림을 얻었다. 여기서 **데이터 소스**는 요리 리스트(메뉴)다. 데이터 소스는 **연속된 요소**를 스트림에 제공한다. 다음으로 스트램에 filter, map, limit, collect로 이어지는 일련의 **데이터 처리 연산**을 적용한다. collect를 제외한 모든 연산은 서로 **파이프라인**을 형성할 수 있도록 스트림을 반환한다. 파이프라인은 소스에 적용하는 질의 같은 존재다. 마지막으로 collect 연산으로 파이프라인을 처리해서 결과를 반환한다(collect는 스트림이 아니라 List를 반환한다). 마지막에 collect를 호출하기 전까지는 menu에서 무엇도 선택되지 않으며 출력 결과도 없다. 즉 collect가 호출되기 전까지 메서드 호출이 저장되는 효과가 있다. `filter`, `map`, `limit`, `collect`는 각각 다음 작업을 수행한다.

## 스트림 연산

`java.util.stream.Stream` 인터페이스는 많은 연산을 정의한다. 스트림 인터페이스의 연산을 크게 중간 연산(intermediate operation)과 최종 연산(terminal operation)으로 구분할 수 있다.

### 중간 연산(intermediate operation)

- `filter`, `map`, `limit` 같은 **중간 연산은 다른 스트림을 반환**한다. 따라서 **여러 중간 연산을 연결해서 질의를 만들 수 있다.**
- 스트림 연산은 원본을 변경하지 않는다. 예를 들어 filter 메서드는 스트림에서 요소를 지우는 것이 아니라 **해당 요소가 없는 새 스트림을 돌려준다.**
- 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것, 즉 게으르다(**lazy**)는 것이다. **중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리**하기 때문이다. 예를 들어 긴 단어를 모두 요청하지 않고 처음 다섯 개만 요청했다면, filter 메서드는 다섯 번째 일치 단어를 찾은 후 필터링을 중단한다.

### 최종 연산(terminal operation)

- 최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에 의해 List, Integer, void 등 스트림 이외의 결과가 반환된다. 위의 예에서는 `collect(toList())` 연산을 통해 List의 결과가 반환된다.

![https://s29840.pcdn.co/wp-content/uploads/2020/06/238.Java-streams.jpg](https://s29840.pcdn.co/wp-content/uploads/2020/06/238.Java-streams.jpg)

스트림 연산에 대한 자세한 설명은 API 문서를 확인하자.

[https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.html](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.html)

## 스트림 vs 컬렉션

자바의 기존 컬렉션과 새로운 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다.

### **컬렉션의 주제는 ‘데이터’고 스트림의 주제는 ‘계산’이다**

**컬렉션**은 자료구조이므로 컬렉션에서는 (예를 들어 ArrayList를 사용할 것인지 아니면 LinkedList를 사용할 것인지에 대한) 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다. 반면 **스트림**은 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소(Sequence of elements)이므로 `filter`, `sorted`, `map`처럼 표현 계산식이 주를 이룬다. **즉, 컬렉션의 주제는 데이터고 스트림의 주제는 계산이다.**

### 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이다

컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. 즉, **컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다**(컬렉션에 요소를 추가하거나 컬렉션의 요소를 삭제할 수 있다. 이런 연산을 수행할 때마다 컬렉션의 모든 요소를 메모리에 저장해야 하며 컬렉션에 추가하려는 요소는 미리 계산되어야 한다).

**반면 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조**다(스트림에 요소를 추가하거나 스트림에서 요소를 제거할 수 없다). 이러한 스트림의 특성은 프로그래밍에 큰 도움을 준다. 이를 통해 간단하게 무제한의 소수(2, 3, 5, 7, 11, ...)를 포함하는 스트림을 만들 수도 있다. 스트림은 게으르게(lazy) 만들어지는 컬렉션과 같다. 사용자가 데이터를 요청할 때만 값을 계산한다.

반면 컬렉션은 모든 요소가 컬렉션에 추가되기 전에 계산되어야 한다. 소수 예제에 이를 적용해보자. 컬렉션은 끝이 없는 모든 소수를 포함하려 할 것이므로 무한 루프를 돌면서 새로운 소수를 계산하고 추가하기를 반복할 것이다. 결국 소비자는 영원히 결과를 볼 수 없게 된다.

### 스트림은 데이터 소스를 변경하지 않는다

스트림은 데이터 소스로 부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다. 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.

```xml
// 정렬된 결과를 새로운 List에 담아서 반환한다.
List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
```

### 딱 한 번만 탐색할 수 있다

스트림은 `Iterator`처럼 일회용이다. `Iterator`로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼, 스트림도 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야한다. 

```java
strStream1.sorted().forEach(System.out::println);
int numOfStr = strStream1.count(); // 에러. 스트림이 이미 닫혔음.
```

### 스트림은 ‘어떻게’가 아니라 ‘**무엇을**'이라는 원칙을 따른다.

컬렉션은 외부적으로 반복, 즉 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다. 예를 들어 책에 나오는 긴 단어를 모두 센다고 하자. 우선 긴 단어들을 리스트에 집어 넣자.

```java
String contents = new String(Files.readAllBytes(
		Paths.get("alice.txt")), StandardCharsets.UTF-8);
List<String> words = List.of(contents.split("\\PL+"));
		// 단어로 분리한다(비문자(글자가 아닌 문자)를 구분자로 사용한다).
```

이제 다음과 같이 반복할 수 있다.

```java
int count = 0;
for (String w : words) {
	if (w.length() > 12) count++
}
```

스트림을 이용하면 같은 연산을 다음과 같이 수행할 수 있다.

```java
long count = words.stream()
		.filter(w -> w.length() > 12)
		.count();
```

단순히 `stream`만 `parallelStream`으로 바꾸어 주면 스트림 라이브러리에서 필터링과 카운팅을 **병렬**로 수행한다.

```java
long count = words.parallelStream()
		.filter(w -> w.length() > 12)
		.count();
```

스트림은 ‘어떻게가 아니라 **무엇을**'이라는 원칙을 따른다. 스트림 예제에서는 수행해야 하는 일(긴 단어를 얻어와서 세는 일)을 기술했다. 일을 수행할 순서나 스레드는 명시하지 않았다. 반면에 첫 부분에 나온 루프는 계산을 정확히 어떻게 수행해야 하는지 명시하므로 최적화 기회를 놓치고 만다.

스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다. 반면 for-each를 이용하는 외부 반복에서는 병렬성을 스스로 관리해야 한다(병렬성을 스스로 관리한다는 것은 병렬성을 포기하든지 아니면 synchronized로 시작하는 힘들고 긴 전쟁을 시작함을 의미한다).

내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다. 기존 자바에서처럼 컬렉션을 외부 반복으로 처리한다면 이와 같은 최적화를 달성하기 어렵다.

---

## 참조

<라울-게이브리얼 우르마 외, 모던 자바 인 액션 , 한빛미디어>

<카이 호스트만, 가장 빨리 만나는 코어 자바9, 길벗>

<남궁성, 자바의 정석, 도우출판>
